"""
SIS rules engine for validating infrastructure resources
"""

import re
from typing import Any, Dict, List, Optional, Union, cast


def resolve_path_values(root: Dict[str, Any], path: str) -> List[Any]:
    """
    Resolve a path with existential array semantics.
    
    Args:
        root: The resource to search
        path: Path with optional [] for array existential matching
        
    Returns:
        List of terminal values that exist at the path (empty list if none)
    """
    if not path:
        return [root]
    
    parts = path.split('.')
    current_values = [root]
    
    for part in parts:
        next_values = []
        is_array = part.endswith('[]')
        key = part[:-2] if is_array else part
        
        for current in current_values:
            if not isinstance(current, dict):
                continue
            
            value = current.get(key)
            
            if is_array:
                # Array existential: collect all elements
                if isinstance(value, list):
                    for item in value:
                        next_values.append(item)
                # If it's not a list, treat as empty (no values to add)
            else:
                # Non-array: just add the value
                next_values.append(value)
        
        current_values = next_values
    
    return current_values


def check_condition(resource: Dict[str, Any], condition: Dict[str, Any]) -> bool:
    """
    Check if a resource matches a condition with existential array semantics.
    
    Args:
        resource: The resource to check
        condition: Condition definition with path, operator, value
        
    Returns:
        True if condition matches, False otherwise
    """
    path = condition.get("path", "")
    operator = condition.get("operator", "")
    value = condition.get("value", "")
    
    # Resolve all terminal values at the path
    values = resolve_path_values(resource, path)
    
    # Handle existence operators
    if operator == "EXISTS":
        # EXISTS: true if at least one non-None value exists
        return any(v is not None for v in values)
    
    if operator == "NOT_EXISTS":
        # NOT_EXISTS: true if no non-None values exist
        return not any(v is not None for v in values)
    
    # For other operators, check if ANY value matches
    for current in values:
        if current is None:
            continue
            
        # Convert current to string for comparison
        current_str = str(current).lower()
        value_str = str(value).lower()
        
        if operator == "EQUALS":
            if current_str == value_str:
                return True
        elif operator == "NOT_EQUALS":
            if current_str != value_str:
                return True
        elif operator == "CONTAINS":
            if value_str in current_str:
                return True
        elif operator == "REGEX":
            try:
                if re.search(value_str, current_str, re.IGNORECASE):
                    return True
            except re.error:
                continue  # Invalid regex, try next value
        elif operator == "IN":
            if isinstance(value, list):
                value_list = [str(v).lower() for v in value]
                if current_str in value_list:
                    return True
            # If value is not a list, can't match
    
    # No value matched the operator
    return False


def check_resource_rule(
    resource: Dict[str, Any], rule: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """
    Check if a resource violates a specific rule.

    Args:
        resource: The resource to check
        rule: Rule definition

    Returns:
        Violation dict if rule is violated, None otherwise
    """
    rule_id = rule.get("rule_id", "")
    rule_type = rule.get("rule_type", "")

    # Check if rule applies to this resource type
    applies_to = rule.get("applies_to", {})
    resource_kinds = applies_to.get("resource_kinds", [])

    resource_type = resource.get("type") or resource.get("kind", "")
    if (
        resource_kinds
        and resource_kinds != ["*"]
        and resource_type not in resource_kinds
    ):
        return None

    # Check detection conditions
    detection = rule.get("detection", {})
    match_logic = detection.get("match_logic", "ALL")
    conditions = detection.get("conditions", [])

    condition_results = []
    for condition in conditions:
        condition_results.append(check_condition(resource, condition))

    # Apply match logic
    if match_logic == "ALL":
        violates = all(condition_results)
    elif match_logic == "ANY":
        violates = any(condition_results)
    elif match_logic == "NONE":
        violates = not any(condition_results)
    else:
        violates = False

    if violates:
        return {
            "rule_id": rule_id,
            "rule_type": rule_type,
            "resource_id": resource.get("name", "unknown"),
            "resource_type": resource_type,
            "severity": rule.get("severity", "medium").upper(),
            "message": rule.get("message", "Rule violation"),
            "location": {"line": resource.get("line", 0)},
            "remediation": rule.get("remediation", ""),
                "_pack": rule.get("_pack", "N/A"),
                "_pack_version": rule.get("_pack_version", "N/A"),
        }

    return None


def validate_resources(
    resources: List[Dict[str, Any]], rules: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Validate resources against SIS rules.

    Args:
        resources: List of resources to validate
        rules: List of rules to check

    Returns:
        List of violations found
    """
    violations: List[Dict[str, Any]] = []

    for resource in resources:
        for rule in rules:
            violation = check_resource_rule(resource, rule)
            if violation:
                violations.append(violation)

    return violations
